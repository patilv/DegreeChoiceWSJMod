{
    "contents" : "---\nlayout: post\ntitle: \"Using great circles and ggplot2 to map arrival/departure of 2014 US Open Tennis Players\"\ndescription: \"US Open\"\ntags: [R, ggplot2]\ncomments: true\nshare: true\n---\nThis was one of the few visualizations I worked on during the 2014 US Open Tennis Championships. Thanks to [Alex Bresler](https://twitter.com/abresler) and [Aragorn Technologies](https://github.com/AragornTech) for the data and opportunity to work with a great group of people. In this one, we'll take a look at player's countries, particularly the potential flight paths to and from New York City. For this, connections between countries and NYC were created using great circles. We will also modify the opacity of connecting arcs based on the number of players traveling from a particular country.   \n\nMy first exposure to great circles was from Nathan Yau's excellent tutorial at flowingdata on [How to map connections with great circles](http://flowingdata.com/2011/05/11/how-to-map-connections-with-great-circles/). In it, Nathan shows how to draw connecting lines using ```gcIntermediate()``` from the ```geosphere``` package and uses them to create maps of airline flights for different carriers in the US. Most of my code, however, comes from a blog post at AnthroSpace titled [Great Circles on a recentered worldmap in ggplot](http://web.stanford.edu/~cengel/cgi-bin/anthrospace/great-circles-on-a-recentered-worldmap-in-ggplot). In that post, AnthroSpace recentered the world map and showed data on flights out of Beijing, China. A section of the code from AnthroSpace's post was also used in this post with a beautiful output at [spatial.ly for mapping the world's biggest airlines.](http://spatial.ly/2012/06/mapping-worlds-biggest-airlines/). \n\nCode and data for this post can be found on my [github site here.](https://github.com/patilv/USOpengreatcircles)\n\n## Data\n\nData on countries of US Open Players were gathered from the different brackets.\n\n```{r results='asis'}\nlibrary(ggplot2)\nlibrary(ggmap)\nlibrary(geosphere)\nlibrary(plyr)\n\nmensbracket=read.csv(\"mensbracket.csv\") \nladiesbracket=read.csv(\"ladiesbracket.csv\")\nusopenbracket=rbind(mensbracket,ladiesbracket) # combining the two genders\nusopencountry=as.data.frame(table(usopenbracket$country)) # number of players from different countries\ncolnames(usopencountry)=c(\"Country\",\"Players\") # modifying column names\nkable(head(usopencountry))\n```\n\n## Latitude and longitude information of different countries\n\nWe do this by geocoding the countries using the function from ```ggmap``` which uses google map's API. \n\n```{r results='asis'}\nusopencountry=cbind(usopencountry,geocode(as.character(usopencountry$Country)))\nkable(head(usopencountry))\n```\n\nPast experience of mine has suggested that some of the results of geocoding go off the mark. Although we could use this function with precise addresses, at times, we might want to use country names or names of institutions in different locations to geocode. So, some error should be expected. (The exact location of the geocoded spot for the US, for example, is in Kansas.) After manually checking the latitude and longitude information using google maps, information for three countries had to be changed. (For example, Bosnia was shown as being in Chile and the location referring to New Zealand was a marker off the coast in the ocean.) We manually correct this. (I would be interested in a different but accurate approach, if there's one you are aware of.) And, let's not forget geocoding New York City.\n\n```{r}\nusopencountry[5,]$lon=18.383925 # Bosnia\nusopencountry[5,]$lat=43.851882 # Bosnia\nusopencountry[11,]$lon=33.3974183 # Cyprus\nusopencountry[11,]$lat=35.1919937 # Cyprus\nusopencountry[45,]$lon=174.885971 # New Zealand\nusopencountry[45,]$lat=-40.900557 # New Zealand\nnygeocode=geocode(as.character(\"New York City\")) # This was fine\n```\n\n## On to the great circles.\n\n```{r}\n# Calculating routes \nroutes = gcIntermediate(nygeocode, usopencountry[,c('lon', 'lat')], 200, breakAtDateLine=FALSE, addStartEnd=TRUE, sp=TRUE)\n\n# fortifying the routes information to create a dataframe; function from ggplot's github site ... thanks to the comments section in AnthroSpace's post\n\nfortify.SpatialLinesDataFrame = function(model, data, ...) {\n  ldply(model@lines, fortify)\n}\n\nfortifiedroutes = fortify.SpatialLinesDataFrame(routes) \n\n# An id for each country\nusopencountry$id=as.character(c(1:nrow(usopencountry))) \n\n# Merge fortified routes with usopencountry information\ngreatcircles = merge(fortifiedroutes, usopencountry, all.x=T, by=\"id\") \n\n### Recentering the world map ####\n\ncenter = 290 # takes positive values - US centered view is 260. This took a bit to figure out to avoid splitting of arcs in the final map.\n\n# shifting coordinates to recenter great circles\ngreatcircles$long.recenter =  ifelse(greatcircles$long  < center - 180 , greatcircles$long + 360, greatcircles$long) \n\n# shifting coordinates to recenter worldmap\nworldmap = map_data (\"world\")\nworldmap$long.recenter =  ifelse(worldmap$long  < center - 180 , worldmap$long + 360, worldmap$long)\n\n### Function to regroup split lines and polygons\n# takes dataframe, column with long and unique group variable, returns df with added column named group.regroup\nRegroupElements = function(df, longcol, idcol){  \n  g = rep(1, length(df[,longcol]))\n  if (diff(range(df[,longcol])) > 300) {          # check if longitude within group differs more than 300 deg, ie if element was split\n    d = df[,longcol] > mean(range(df[,longcol])) # we use the mean to help us separate the extreme values\n    g[!d] = 1     # some marker for parts that stay in place (we cheat here a little, as we do not take into account concave polygons)\n    g[d] = 2      # parts that are moved\n  }\n  g =  paste(df[, idcol], g, sep=\".\") # attach to id to create unique group variable for the dataset\n  df$group.regroup = g\n  df\n}\n\n### Function to close regrouped polygons\n# takes dataframe, checks if 1st and last longitude value are the same, if not, inserts first as last and reassigns order variable\nClosePolygons = function(df, longcol, ordercol){\n  if (df[1,longcol] != df[nrow(df),longcol]) {\n    tmp = df[1,]\n    df = rbind(df,tmp)\n  }\n  o = c(1: nrow(df))  # rassign the order variable\n  df[,ordercol] = o\n  df\n}\n\n# regrouping\nregroupedgreatcircles = ddply(greatcircles, .(id), RegroupElements, \"long.recenter\", \"id\")\nregroupedworldmap = ddply(worldmap, .(group), RegroupElements, \"long.recenter\", \"group\")\n\n# close polygons\nworldmap.closedpolygons = ddply(regroupedworldmap, .(group.regroup), ClosePolygons, \"long.recenter\", \"order\")  \n```\n\n## Final leg, the plot. \n\nYou can mess around with many parameters below. For example, the size of lines, colours of country borders, and a whole host of other things. \n\n```{r fig.width=21, fig.height=18}\nggplot() +\n  geom_polygon(aes(long.recenter,lat,group=group.regroup), size = 0.1, fill=\"black\", colour = \"#4D4D4D\", data=worldmap.closedpolygons) +\n  geom_line(aes(long.recenter,lat.x,group=group.regroup, color=Country, alpha=Players), size=1,data= regroupedgreatcircles)+ \n  theme(panel.grid.minor = element_blank(), panel.grid.major = element_blank(),  axis.ticks = element_blank(), axis.title= element_blank(), \n         axis.text = element_blank(),legend.position = \"none\")+\n  ylim(-60, 90) +theme(panel.background = element_rect(fill = 'black'))+\n  coord_equal()+annotate(\"text\",x=max(worldmap.closedpolygons$long.recenter),y=-60,hjust=.9,size=3,\nlabel=paste(\"Arrival/Departures of US Open Players\",\"your name\",sep=\"\\n\"),color=\"white\") \n```\n",
    "created" : 1413837902514.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "480830967",
    "id" : "34674C20",
    "lastKnownWriteTime" : 1410959186,
    "path" : "~/GitHub/patilv.github.io/_Rmd/2014-9-17-USOpenCountries.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_markdown"
}